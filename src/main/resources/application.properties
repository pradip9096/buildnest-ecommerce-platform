spring.application.name=buildnest-ecommerce
# Server Configuration
server.port=8080
server.servlet.context-path=/

# Graceful Shutdown Configuration (LOW PRIORITY #8)
# Allows in-flight requests to complete before shutdown
# Timeout: 30 seconds for request completion, connection draining, and thread pool shutdown
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s

# HTTPS/TLS Configuration (RQ-SEC-05)
# Set to true to enforce HTTPS in production
# Configure with environment: SERVER_SSL_ENABLED, SERVER_SSL_KEY_STORE, SERVER_SSL_KEY_STORE_PASSWORD
server.ssl.enabled=${SERVER_SSL_ENABLED:false}
server.ssl.key-store=${SERVER_SSL_KEY_STORE:}
server.ssl.key-store-password=${SERVER_SSL_KEY_STORE_PASSWORD:}
server.ssl.key-store-type=PKCS12

# Database Configuration (PERFORMANCE_OPTIMIZATION_GUIDE - Database Optimization)
# Override with environment variables: SPRING_DATASOURCE_URL, SPRING_DATASOURCE_USERNAME, SPRING_DATASOURCE_PASSWORD
# WARNING: Default credentials below are for development only. Use environment variables in production.
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:mysql://localhost:3306/buildnest_ecommerce}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:root}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# HikariCP Connection Pool Configuration (PERFORMANCE_OPTIMIZATION_GUIDE - Connection Pool Tuning)
# Optimize for medium traffic (typical e-commerce workload)
spring.datasource.hikari.maximum-pool-size=${DB_POOL_MAX_SIZE:20}
spring.datasource.hikari.minimum-idle=${DB_POOL_MIN_IDLE:10}
spring.datasource.hikari.connection-timeout=${DB_CONNECTION_TIMEOUT:30000}
spring.datasource.hikari.idle-timeout=${DB_IDLE_TIMEOUT:600000}
spring.datasource.hikari.max-lifetime=${DB_MAX_LIFETIME:1800000}
spring.datasource.hikari.auto-commit=true
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.leak-detection-threshold=60000

# JPA Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.open-in-view=false

# Liquibase Configuration (SYS-DATA-008)
# Database migration tool for version-controlled schema management
# Disable Liquibase in development by setting to false
spring.liquibase.enabled=${LIQUIBASE_ENABLED:true}
spring.liquibase.change-log=classpath:db/changelog/db.changelog-master.sql
spring.liquibase.contexts=
spring.liquibase.default-schema=${SPRING_DATASOURCE_URL_SCHEMA:buildnest_ecommerce}

# JWT Configuration (1.1 CRITICAL - JWT Secret Key Management)
# SYS-JWT-004: Access token expiration = 15 minutes (900000 milliseconds)
# SYS-JWT-005: Refresh token expiration = 30 days (2592000000 milliseconds)
# CRITICAL: JWT_SECRET environment variable is REQUIRED in production
# Minimum 512-bit key generated: openssl rand -base64 64
# No default value - application will fail fast if not configured
jwt.secret=${JWT_SECRET}
jwt.expiration=${JWT_EXPIRATION:900000}
jwt.refresh.expiration=${JWT_REFRESH_EXPIRATION:2592000000}

# Password Reset Token Configuration (1.2 MEDIUM - Password Reset Token Expiration)
# OWASP recommendation: 15 minutes maximum for sensitive operations
password.reset.token.expiration=${PASSWORD_RESET_EXPIRATION:900000}

# Logging Configuration
logging.level.root=INFO
logging.level.com.example.buildnest_ecommerce=DEBUG
logging.pattern.console={"timestamp":"%d{ISO8601}","level":"%p","logger":"%c","thread":"%t","message":"%m","mdc":%X}%n

# Swagger/OpenAPI Configuration
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.enabled=true

# Redis Configuration (PERFORMANCE_OPTIMIZATION_GUIDE - Cache Optimization)
# Default to localhost:6379 for development
# Override with environment variables for production:
#   REDIS_HOST, REDIS_PORT, REDIS_PASSWORD
# Production Optimization: Increased pool size for high concurrency
spring.data.redis.host=${REDIS_HOST:localhost}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.timeout=${REDIS_TIMEOUT:3000}
spring.data.redis.jedis.pool.max-active=${REDIS_POOL_MAX_ACTIVE:8}
spring.data.redis.jedis.pool.max-idle=${REDIS_POOL_MAX_IDLE:8}
spring.data.redis.jedis.pool.min-idle=${REDIS_POOL_MIN_IDLE:0}
spring.data.redis.jedis.pool.max-wait-millis=${REDIS_POOL_MAX_WAIT:5000}

# Spring Cache Configuration (RQ-NFR-03)
# Use Redis as the cache backend with optimized TTL strategy
spring.cache.type=redis
spring.cache.redis.time-to-live=${CACHE_TTL:900000}
spring.cache.redis.cache-null-values=false

# Cache TTL by Region (PERFORMANCE_OPTIMIZATION_GUIDE - Section 9)
# LOW PRIORITY #14: Single Source of Truth - All cache TTLs configured externally
# All values in milliseconds - can be overridden per environment
cache.ttl.products=${CACHE_TTL_PRODUCTS:300000}
cache.ttl.categories=${CACHE_TTL_CATEGORIES:3600000}
cache.ttl.users=${CACHE_TTL_USERS:1800000}
cache.ttl.orders=${CACHE_TTL_ORDERS:600000}
cache.ttl.rate-limit-stats=${CACHE_TTL_RATE_LIMIT:60000}
cache.ttl.audit-logs=${CACHE_TTL_AUDIT_LOGS:900000}
cache.ttl.user-permissions=${CACHE_TTL_PERMISSIONS:3600000}
cache.ttl.inventory-items=${CACHE_TTL_INVENTORY:300000}

# Rate Limiting Configuration (PERFORMANCE_OPTIMIZATION_GUIDE - Rate Limiting & Circuit Breaker)
# All times in seconds, requests is count per time window
# Production optimization: Tuned based on 7-day traffic analysis (RATE_LIMITING_ANALYSIS.md)

# Authentication endpoints - stricter limits to prevent brute force attacks
rate.limit.login.requests=${RATE_LIMIT_LOGIN_REQUESTS:3}
rate.limit.login.duration=${RATE_LIMIT_LOGIN_DURATION:300}

# Password reset - very strict to prevent abuse
rate.limit.password-reset.requests=${RATE_LIMIT_PASSWORD_RESET_REQUESTS:3}
rate.limit.password-reset.duration=${RATE_LIMIT_PASSWORD_RESET_DURATION:3600}

# Token refresh - moderate limits
rate.limit.refresh-token.requests=${RATE_LIMIT_REFRESH_TOKEN_REQUESTS:10}
rate.limit.refresh-token.duration=${RATE_LIMIT_REFRESH_TOKEN_DURATION:60}

# Product search - TUNED: Increased from 50 to 60 based on P99 analysis (HIGH #5)
rate.limit.product-search.requests=${RATE_LIMIT_PRODUCT_SEARCH_REQUESTS:60}
rate.limit.product-search.duration=${RATE_LIMIT_PRODUCT_SEARCH_DURATION:60}

# Admin endpoints - TUNED: Increased from 30 to 50 for bulk operations (HIGH #5)
rate.limit.admin.requests=${RATE_LIMIT_ADMIN_REQUESTS:50}
rate.limit.admin.duration=${RATE_LIMIT_ADMIN_DURATION:60}

# User endpoints - general API rate limiting (optimal as-is)
rate.limit.user.requests=${RATE_LIMIT_USER_REQUESTS:500}
rate.limit.user.duration=${RATE_LIMIT_USER_DURATION:60}

# Circuit Breaker Configuration (PERFORMANCE_OPTIMIZATION_GUIDE - Resilience4j)
# Failure rate threshold for opening circuit (percentage)
resilience4j.circuitbreaker.instances.redis-circuit-breaker.failure-rate-threshold=${REDIS_CB_FAILURE_THRESHOLD:70}
resilience4j.circuitbreaker.instances.redis-circuit-breaker.wait-duration-in-open-state=${REDIS_CB_WAIT_DURATION:60000}
resilience4j.circuitbreaker.instances.redis-circuit-breaker.minimum-number-of-calls=${REDIS_CB_MIN_CALLS:5}

# Database circuit breaker - fail fast on database issues
resilience4j.circuitbreaker.instances.database-circuit-breaker.failure-rate-threshold=${DB_CB_FAILURE_THRESHOLD:50}
resilience4j.circuitbreaker.instances.database-circuit-breaker.wait-duration-in-open-state=${DB_CB_WAIT_DURATION:30000}
resilience4j.circuitbreaker.instances.database-circuit-breaker.minimum-number-of-calls=${DB_CB_MIN_CALLS:10}
# API endpoints general rate limiting
rate.limit.api.requests=200
rate.limit.api.duration=60

# Resilience4j Circuit Breaker Configuration (RQ-NFR-02)
# Redis circuit breaker
resilience4j.circuitbreaker.instances.redis-circuit-breaker.register-health-indicator=true
resilience4j.circuitbreaker.instances.redis-circuit-breaker.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.redis-circuit-breaker.wait-duration-in-open-state=30000
resilience4j.circuitbreaker.instances.redis-circuit-breaker.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.redis-circuit-breaker.minimum-number-of-calls=3

# Database circuit breaker
resilience4j.circuitbreaker.instances.database-circuit-breaker.register-health-indicator=true
resilience4j.circuitbreaker.instances.database-circuit-breaker.failure-rate-threshold=60
resilience4j.circuitbreaker.instances.database-circuit-breaker.wait-duration-in-open-state=60000
resilience4j.circuitbreaker.instances.database-circuit-breaker.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.database-circuit-breaker.minimum-number-of-calls=5

# Resilience4j Time Limiter Configuration
resilience4j.timelimiter.instances.redis-time-limiter.timeout-duration=3s
resilience4j.timelimiter.instances.redis-time-limiter.cancel-running-future=true

resilience4j.timelimiter.instances.database-time-limiter.timeout-duration=8s
resilience4j.timelimiter.instances.database-time-limiter.cancel-running-future=true

# Payment Gateway (Razorpay) Configuration
# Override with environment variables: RAZORPAY_KEY_ID, RAZORPAY_KEY_SECRET
razorpay.key.id=${RAZORPAY_KEY_ID:test_key_id}
razorpay.key.secret=${RAZORPAY_KEY_SECRET:test_key_secret}

# HikariCP Connection Pool Configuration (2.1 MEDIUM - Database Connection Pooling)
# Production optimization: increased pool size for higher concurrency
spring.datasource.hikari.maximum-pool-size=${HIKARI_MAX_POOL_SIZE:20}
spring.datasource.hikari.minimum-idle=${HIKARI_MIN_IDLE:10}
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.leak-detection-threshold=60000
spring.datasource.hikari.auto-commit=true

# OAuth2 Client Configuration (RQ-MAINT-03)
# Configure OAuth2 providers via environment variables:
# SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_ID
# SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GOOGLE_CLIENT_SECRET
# SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GITHUB_CLIENT_ID
# SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_GITHUB_CLIENT_SECRET
spring.security.oauth2.client.registration.google.client-id=${GOOGLE_CLIENT_ID:}
spring.security.oauth2.client.registration.google.client-secret=${GOOGLE_CLIENT_SECRET:}
spring.security.oauth2.client.registration.github.client-id=${GITHUB_CLIENT_ID:}
spring.security.oauth2.client.registration.github.client-secret=${GITHUB_CLIENT_SECRET:}

# Actuator Configuration
management.endpoints.web.exposure.include=health,info,metrics,prometheus,httptrace,loggers
management.endpoint.health.show-details=when-authorized
management.endpoint.health.probes.enabled=true
management.health.livenessstate.enabled=true
management.health.readinessstate.enabled=true

# Health Check Configuration (HIGH #3)
# Composite health indicators for database, Redis, and circuit breakers
management.health.db.enabled=true
management.health.redis.enabled=true
management.health.circuitbreakers.enabled=true
management.health.diskspace.enabled=true

management.metrics.export.prometheus.enabled=true
management.metrics.distribution.percentiles-histogram.http.server.requests=true
management.metrics.tags.application=${spring.application.name}
management.metrics.tags.environment=${ENVIRONMENT:dev}

# Chaos Engineering (5.6 LOW)
chaos.enabled=${CHAOS_ENABLED:false}
chaos.error.rate=${CHAOS_ERROR_RATE:0.02}
chaos.delay.ms=${CHAOS_DELAY_MS:200}
# Elasticsearch Configuration (RQ-ES-02, RQ-ES-ING-01, RQ-ES-LOG-01)
# Default to localhost:9200 for development
# Override with environment variables for production:
#   ELASTICSEARCH_HOST, ELASTICSEARCH_PORT, ELASTICSEARCH_USERNAME, ELASTICSEARCH_PASSWORD, ELASTICSEARCH_SSL_ENABLED
elasticsearch.host=${ELASTICSEARCH_HOST:localhost}
elasticsearch.port=${ELASTICSEARCH_PORT:9200}
elasticsearch.username=${ELASTICSEARCH_USERNAME:elastic}
elasticsearch.password=${ELASTICSEARCH_PASSWORD:}
elasticsearch.ssl.enabled=${ELASTICSEARCH_SSL_ENABLED:false}

# Elasticsearch Alerting Configuration (RQ-ES-ALRT-01, RQ-ES-ALRT-02)
elasticsearch.alert.enabled=${ELASTICSEARCH_ALERT_ENABLED:true}
elasticsearch.alert.cpu.threshold=${ELASTICSEARCH_ALERT_CPU_THRESHOLD:80}
elasticsearch.alert.memory.threshold=${ELASTICSEARCH_ALERT_MEMORY_THRESHOLD:90}
elasticsearch.alert.error-rate.threshold=${ELASTICSEARCH_ALERT_ERROR_RATE_THRESHOLD:5}
elasticsearch.alert.webhook.url=${ELASTICSEARCH_ALERT_WEBHOOK_URL:}

# Elasticsearch Metrics Configuration (RQ-ES-MON-01, RQ-ES-MON-02)
elasticsearch.metrics.enabled=${ELASTICSEARCH_METRICS_ENABLED:true}

# Webhook Event Handler Configuration (LOW PRIORITY #7)
# Extensible webhook system: Allows adding new webhook handlers without code changes
# Enable/disable webhook handlers per event type for flexible event routing
webhook.events.enabled=${WEBHOOK_EVENTS_ENABLED:true}
webhook.handlers.payment=${WEBHOOK_HANDLERS_PAYMENT:true}
webhook.handlers.inventory=${WEBHOOK_HANDLERS_INVENTORY:true}
webhook.handlers.order=${WEBHOOK_HANDLERS_ORDER:true}
webhook.handlers.alert=${WEBHOOK_HANDLERS_ALERT:true}
webhook.max-retries=${WEBHOOK_MAX_RETRIES:3}
webhook.retry-delay-ms=${WEBHOOK_RETRY_DELAY:5000}

# Logging Configuration - JSON format for Elasticsearch ingestion
logging.pattern.console={"timestamp":"%d{ISO8601}","level":"%p","logger":"%c","thread":"%t","message":"%m","mdc":%X}%n